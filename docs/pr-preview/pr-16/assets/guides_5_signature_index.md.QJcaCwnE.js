import{_ as e,c as a,o as t,a3 as r}from"./chunks/framework.CHPBlGxi.js";const f=JSON.parse('{"title":"🖊️ Signatures","description":"","frontmatter":{},"headers":[],"relativePath":"guides/5_signature/index.md","filePath":"guides/5_signature/index.md","lastUpdated":1716540162000}'),i={name:"guides/5_signature/index.md"},s=r('<h1 id="🖊️-signatures" tabindex="-1">🖊️ Signatures <a class="header-anchor" href="#🖊️-signatures" aria-label="Permalink to &quot;🖊️ Signatures&quot;">​</a></h1><p>The application can produce different types of signatures, using different technologies for different purposes.</p><h2 id="document-signature" tabindex="-1">Document Signature <a class="header-anchor" href="#document-signature" aria-label="Permalink to &quot;Document Signature&quot;">​</a></h2><p>The Signature features allow to you sign documents and files, according to the standards <em>PaDES, CaDES, JaDES or XaDES</em> using your secrets keys and a certificate.</p><h2 id="multisignature-flow" tabindex="-1">Multisignature Flow <a class="header-anchor" href="#multisignature-flow" aria-label="Permalink to &quot;Multisignature Flow&quot;">​</a></h2><p>The Multisignature Flow is a an implementation of the cryptographic flow described in the <a href="https://arxiv.org/abs/2105.14527" target="_blank" rel="noreferrer">Reflow Multisignature</a> paper. This allows users to create a JSON object to be signed, invite users to sign it, set a deadline and wait for their signatures. The signature process uses the homomorphic capabilities of the BLS 12-381 curve - see <a href="https://hackmd.io/@benjaminion/bls12-381" target="_blank" rel="noreferrer">here</a> if you&#39;re curious. The responses are anonymous and the output is a cryptographical object verifiable by anyone.</p>',6),n=[s];function o(u,c,l,d,h,g){return t(),a("div",null,n)}const _=e(i,[["render",o]]);export{f as __pageData,_ as default};
